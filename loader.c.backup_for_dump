/* src/loader.c - instrumented loader with debug prints */
#include "loader.h"
#include "uart.h"
#include <stdint.h>
#include <stddef.h>

/* Addresses must match what kernel expects */
#define PROG_LOAD_ADDR  0x80200000UL
#define PROG_STACK_ADDR 0x80300000UL
#define PROG_STACK_SIZE (16*1024)

/* tiny memcpy */
static void *kmemcpy(void *dst, const void *src, size_t n) {
    uint8_t *d = (uint8_t *)dst;
    const uint8_t *s = (const uint8_t *)src;
    while (n--) *d++ = *s++;
    return dst;
}

/* helper to print integer (decimal without newline) */
static void uart_print_u_nl(size_t v) {
    if (v == 0) { uart_putc('0'); uart_putc('\n'); return; }
    char buf[32];
    int i = 0;
    while (v > 0 && i < (int)sizeof(buf)-1) {
        buf[i++] = '0' + (v % 10);
        v /= 10;
    }
    for (int j = i-1; j >= 0; --j) uart_putc(buf[j]);
    uart_putc('\n');
}

/* list programs */
void loader_list_programs(void) {
    uart_puts("Programs:\n");
    if (prog_table_count == 0) {
        uart_puts("  (none)\n");
        return;
    }
    for (size_t i = 0; i < prog_table_count; ++i) {
        uart_puts("  ");
        uart_puts(prog_table[i].name);
        uart_puts("\n");
    }
}

/* robust exact-string compare (returns 1 if equal) */
static int str_equal(const char *a, const char *b) {
    while (*a && *b) {
        if (*a != *b) return 0;
        a++; b++;
    }
    return *a == *b;
}

/* run by name with verbose debug output */
int loader_run_by_name(const char *name) {
    if (!name) return -1;

    uart_puts("[DEBUG] loader_run_by_name called with name='");
    uart_puts(name);
    uart_puts("'\n");

    uart_puts("[DEBUG] prog_table_count = ");
    uart_print_u_nl(prog_table_count);

    /* print each entry */
    for (size_t i = 0; i < prog_table_count; ++i) {
        uart_puts("[DEBUG] entry ");
        /* print index (handles up to 99) */
        uart_putc('0' + (char)((i/10)%10));
        uart_putc('0' + (char)(i%10));
        uart_puts(": name='");
        uart_puts(prog_table[i].name ? prog_table[i].name : "(null)");
        uart_puts("', size=");
        uart_print_u_nl(prog_table[i].size);
    }

    /* now compare */
    for (size_t i = 0; i < prog_table_count; ++i) {
        uart_puts("[DEBUG] comparing to entry ");
        uart_putc('0' + (char)((i/10)%10));
        uart_putc('0' + (char)(i%10));
        uart_puts(": '");
        uart_puts(prog_table[i].name ? prog_table[i].name : "(null)");
        uart_puts("'\n");

        if (prog_table[i].name && str_equal(name, prog_table[i].name)) {
            uart_puts("[DEBUG] MATCH FOUND for entry ");
            uart_putc('0' + (char)((i/10)%10));
            uart_putc('0' + (char)(i%10));
            uart_puts("\n");

            if (!prog_table[i].data || prog_table[i].size == 0) {
                uart_puts("[LOADER] error: program has no data or size==0\n");
                return -1;
            }

            uart_puts("Loading program: ");
            uart_puts(prog_table[i].name);
            uart_puts("\n");

            /* copy program to load address */
            kmemcpy((void*)PROG_LOAD_ADDR, prog_table[i].data, prog_table[i].size);

            uintptr_t entry = (uintptr_t)(prog_table[i].entry ? prog_table[i].entry : (const void*)PROG_LOAD_ADDR);
            uintptr_t user_sp = PROG_STACK_ADDR;

            /* debug: print entry & stack pointers */
            uart_puts("[DEBUG] entry addr = 0x");
            /* simple hex print */
            {
                uintptr_t x = entry;
                char hx[17];
                for (int k = 0; k < 16; ++k) hx[k] = '0';
                hx[16] = '\0';
                int pos = 15;
                while (x && pos >= 0) {
                    int ny = x & 0xF;
                    hx[pos--] = (ny < 10) ? ('0' + ny) : ('a' + (ny - 10));
                    x >>= 4;
                }
                uart_puts(hx);
                uart_putc('\n');
            }
            uart_puts("[DEBUG] user_sp = 0x");
            {
                uintptr_t x = user_sp;
                char hx[17];
                for (int k = 0; k < 16; ++k) hx[k] = '0';
                hx[16] = '\0';
                int pos = 15;
                while (x && pos >= 0) {
                    int ny = x & 0xF;
                    hx[pos--] = (ny < 10) ? ('0' + ny) : ('a' + (ny - 10));
                    x >>= 4;
                }
                uart_puts(hx);
                uart_putc('\n');
            }

            /* Save loader SP */
            uintptr_t loader_sp;
            asm volatile("mv %0, sp" : "=r"(loader_sp));

            /* Set user stack */
            asm volatile("mv sp, %0" :: "r"(user_sp) : );

            uart_puts("[DEBUG] calling user entry...\n");

            /* Call the entry as a function so `ret` returns to us. */
            typedef void (*user_fn_t)(void);
            user_fn_t fn = (user_fn_t)entry;
            fn();   /* user program runs and should return using 'ret' */

            uart_puts("[DEBUG] user entry returned\n");

            /* Restore loader SP */
            asm volatile("mv sp, %0" :: "r"(loader_sp) : );

            return 0;
        } else {
            uart_puts("[LOADER] no match for this entry\n");
        }
    }

    uart_puts("[LOADER] no matches found\n");
    return -1;
}
